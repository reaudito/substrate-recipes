<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Substrate-recipes</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="using_events.html"><strong aria-hidden="true">1.</strong> Using Events</a></li><li class="chapter-item expanded "><a href="storage_maps.html"><strong aria-hidden="true">2.</strong> Storage Maps</a></li><li class="chapter-item expanded "><a href="dev_mode.html"><strong aria-hidden="true">3.</strong> Dev Mode</a></li><li class="chapter-item expanded "><a href="cache.html"><strong aria-hidden="true">4.</strong> Cache Locally &gt; Storage Calls</a></li><li class="chapter-item expanded "><a href="vec_set.html"><strong aria-hidden="true">5.</strong> Using Vectors as Set</a></li><li class="chapter-item expanded "><a href="map_set.html"><strong aria-hidden="true">6.</strong> Using Maps as Sets</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Substrate-recipes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="using-events"><a class="header" href="#using-events">Using Events</a></h1>
<p>An event is a mechanism for emitting notifications about specific actions or state changes that occur within a blockchain runtime. Events are typically used to inform the outside world about occurrences such as token transfers, account creations, or other significant operations within the blockchain.</p>
<pre><code class="language-rust  ignore">#[pallet::event]
#[pallet::generate_deposit(pub(super) fn deposit_event)]
pub enum Event&lt;T: Config&gt; {
    /// A user has successfully set a new value.
    SomethingStored {
        /// The new value set.
        something: u32,
        /// The account who set the new value.
        who: T::AccountId,
    },
}</code></pre>
<pre><code class="language-rust  ignore">#[pallet::call_index(0)]
#[pallet::weight(T::WeightInfo::do_something())]
pub fn do_something(origin: OriginFor&lt;T&gt;, something: u32) -&gt; DispatchResult {
    // Check that the extrinsic was signed and get the signer.
    let who = ensure_signed(origin)?;

    // Update storage.
    Something::&lt;T&gt;::put(something);

    // Emit an event.
    Self::deposit_event(Event::SomethingStored { something, who });

    // Return a successful `DispatchResult`
    Ok(())
}</code></pre>
<h2 id="quiz"><a class="header" href="#quiz">Quiz</a></h2>
<div class="quiz-placeholder" data-quiz-name="using_events"  data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;463d3dec-49f2-4748-baa4-75fee31d49d4&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;A notification mechanism&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Transaction on the blockchain&quot;,&quot;A smart contract function&quot;,&quot;A consensus algorithm&quot;],&quot;prompt&quot;:&quot;Which of the following best describes an event in the context of substrate blockchain runtime?\n&quot;}},{&quot;context&quot;:&quot;It may display as a wrong answer, even if the answer is correct, if the spacing does not match. Please ignore it if this happens.&quot;,&quot;id&quot;:&quot;b317de89-93f8-48d1-8157-3c8c28fb5b13&quot;,&quot;type&quot;:&quot;ShortAnswer&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Self::deposit_event(Event::MemberAdded { member_id, who });&quot;},&quot;prompt&quot;:{&quot;prompt&quot;:&quot;Emit the `MemberAdded` event with `member_id` and `who`.\n\n```rust\n#[pallet::event]\n#[pallet::generate_deposit(pub(super) fn deposit_event)]\npub enum Event&lt;T: Config&gt; {\n    MemberAdded {\n        member_id: u32,\n        who: T::AccountId,\n    },\n}\n\n#[pallet::call_index(0)]\n#[pallet::weight(T::WeightInfo::add_member())]\npub fn add_member(origin: OriginFor&lt;T&gt;, member_id: u32) -&gt; DispatchResult {\n    let who = ensure_signed(origin)?;\n\n    MemberId::&lt;T&gt;::put(member_id);\n\n    // Emit an event.\n    ______________________\n\n    Ok(())\n}\n```\n&quot;}}]}" ></div>
<script type="text/javascript" src="quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-a-storagemap"><a class="header" href="#declaring-a-storagemap">Declaring a <code>StorageMap</code></a></h1>
<p><code>pallets/simple-map</code>
<a target="_blank" href="https://github.com/reaudito/substrate-recipes/blob/main/polkadot-sdk-solochain-template/pallets/simple-map/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt ="View on GitHub"/>
</a></p>
<p>We declare a single storage map with the following syntax:</p>
<pre><code class="language-rust  ignore">#[pallet::storage]
#[pallet::getter(fn simple_map)]
pub(super) type SimpleMap&lt;T: Config&gt; =
    StorageMap&lt;_, Blake2_128Concat, T::AccountId, u32, ValueQuery&gt;;
</code></pre>
<p>Explanation of the code:</p>
<ul>
<li>
<p><code>SimpleMap</code> - the name of the storage map</p>
</li>
<li>
<p><code>#[pallet::getter(fn simple_map)]</code> - a getter function <code>simple_map</code> is created using pallet getter macros.</p>
</li>
<li>
<p><code>Blake2_128Concat</code> - its an hasher used in map. More on this below.</p>
</li>
</ul>
<p>Map contains key and its value:</p>
<ul>
<li>
<p><code>T::AccountId</code> - its the data type of key of the map.</p>
</li>
<li>
<p><code>u64</code> - its the data type of value of the map.</p>
</li>
<li>
<p><code>ValueQuery</code> - If you omit <code>ValueQuery</code>, when interacting with a simple map, you will get an <code>Option&lt;u32&gt;</code>, which means that if you try to get a value from your <code>StorageMap</code>, you will get either <code>Some(value)</code> or <code>None</code>. Using <code>ValueQuery</code> will always return a value, so you don't have to deal with unwrapping the <code>get</code> calls.</p>
</li>
</ul>
<h2 id="choosing-a-hasher"><a class="header" href="#choosing-a-hasher">Choosing a Hasher</a></h2>
<p><a href="https://paritytech.github.io/polkadot-sdk/master/frame_support/trait.StorageHasher.html">Hasher to use to hash keys to insert to storage.</a></p>
<p>Although the syntax above is complex, most of it should be straightforward if you've understood the
recipe on storage values. The last unfamiliar piece of writing a storage map is choosing which
hasher to use. In general you should choose one of the three following hashers. The choice of hasher
will affect the performance and security of your chain. If you don't want to think much about this,
just choose <code>Blake2_128Concat</code> and skip to the next section.</p>
<h3 id="blake2_128concat"><a class="header" href="#blake2_128concat"><code>Blake2_128Concat</code></a></h3>
<p>This is a cryptographically secure hash function, and is always safe to use. It is reasonably
efficient, and will keep your storage tree balanced. You <em>must</em> choose this hasher if users of your
chain have the ability to affect the storage keys. In this pallet, the keys are <code>AccountId</code>s. At
first it may <em>seem</em> that the user doesn't affect the <code>AccountId</code>, but in reality a malicious user
can generate thousands of accounts and use the one that will affect the chain's storage tree in the
way the attacker likes. For this reason, we have chosen to use the <code>Blake2_128Concat</code> hasher.</p>
<h3 id="twox64concat"><a class="header" href="#twox64concat"><code>Twox64Concat</code></a></h3>
<p>This hasher is <em>not</em> cryptographically secure, but is more efficient than blake2. Thus it represents
trading security for performance. You should <em>not</em> use this hasher if chain users can affect the
storage keys. However, it is perfectly safe to use this hasher to gain performance in scenarios
where the users do not control the keys. For example, if the keys in your map are sequentially
increasing indices and users cannot cause the indices to rapidly increase, then this is a perfectly
reasonable choice.</p>
<h3 id="identity"><a class="header" href="#identity"><code>Identity</code></a></h3>
<p>The <code>Identity</code> "hasher" is really not a hasher at all, but merely an
<a href="https://en.wikipedia.org/wiki/Identity_function">identity function</a> that returns the same value it
receives. This hasher is only an option when the key type in your storage map is <em>already</em> a hash,
and is not controllable by the user. If you're in doubt whether the user can influence the key just
use blake2.</p>
<h2 id="the-storage-map-api"><a class="header" href="#the-storage-map-api">The Storage Map API</a></h2>
<p><a href="https://paritytech.github.io/polkadot-sdk/master/frame_support/storage/trait.StorageMap.html">Documentation</a>
This pallet demonstrated some of the most common methods available in a storage map including
<code>insert</code>, <code>get</code>, <code>take</code>, and <code>contains_key</code>.</p>
<pre><code class="language-rust  ignore">// Insert
&lt;SimpleMap&lt;T&gt;&gt;::insert(&amp;user, entry);

// Get
let entry = &lt;SimpleMap&lt;T&gt;&gt;::get(account);

// Take
let entry = &lt;SimpleMap&lt;T&gt;&gt;::take(&amp;user);

// Contains Key
&lt;SimpleMap&lt;T&gt;&gt;::contains_key(&amp;user)

// Mutate
&lt;SimpleMap&lt;T&gt;&gt;::mutate(&amp;user, |entry_option| {
							 *entry_option = Some(entry);
            });</code></pre>
<h2 id="insert-and-mutate"><a class="header" href="#insert-and-mutate"><code>insert</code> and <code>mutate</code></a></h2>
<p>When deciding between <code>mutate</code> and <code>insert</code> to update storage, consider the following:</p>
<p><code>Insert</code> performs a simple write operation to the database, which is the more efficient option.</p>
<p>On the other hand, <code>mutate</code> involves a read operation followed by a write, making it a more expensive database operation.</p>
<p>Therefore, when you have the option to use <code>insert</code> (i.e., you don't need to read the existing value), it's recommended to use <code>insert</code> over <code>mutate</code>.</p>
<p><code>Insert</code> is suitable for inserting or overwriting an existing value. If you simply want to store a specific value, <code>insert</code> is the way to go.</p>
<p><code>Mutate</code>, however, is designed for scenarios where you need to modify the existing value or make decisions based on its current state. Use <code>mutate</code> when you need to perform conditional updates or modifications that depend on the current value."</p>
<h2 id="quiz-1"><a class="header" href="#quiz-1">Quiz</a></h2>
<div class="quiz-placeholder" data-quiz-name="storage_maps"  data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;ec184e84-52ef-4b2c-a9cf-4a79cab76531&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Blake2_128Concat&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Twox64Concat&quot;,&quot;Both are equally secure&quot;,&quot;It depends on the specific use case&quot;],&quot;prompt&quot;:&quot;Which hasher is more secure to use, Blake2_128Concat or Twox64Concat?\n&quot;}},{&quot;id&quot;:&quot;d0060eeb-396f-4896-ac6a-a9c140f112ee&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It is more efficient&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It is more secure&quot;,&quot;It is compatible with more data types&quot;,&quot;It is easier to implement&quot;],&quot;prompt&quot;:&quot;What is the main advantage of using the Twox64Concat hasher?\n&quot;}},{&quot;id&quot;:&quot;e8352c31-5274-4a71-9e99-5f37fed4cc17&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;When users cannot manipulate the storage map keys.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;When users have the ability to generate and control storage map keys.&quot;,&quot;When the storage map values are randomly generated by the system, and user control the keys.&quot;,&quot;When users have the ability to generate and control their own account IDs.&quot;],&quot;prompt&quot;:&quot;In which of the following scenarios is it considered safe to use the Twox64Concat hasher?\n&quot;}},{&quot;id&quot;:&quot;181f71a3-c6b6-4391-9d36-af29b1d4e105&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`Insert` is used when you don't need to read the existing value, while `mutate` is used when you need to modify the existing value.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`Insert` is used for modifying existing values, while `mutate` is used for inserting new values.&quot;,&quot;`Insert` performs a read operation before writing, while `mutate` only performs a write operation.&quot;,&quot;`Insert` is faster than mutate because it uses caching.&quot;],&quot;prompt&quot;:&quot;When updating storage, when is it better to use `insert` instead of `mutate`?\n&quot;}}]}" ></div>
<script type="text/javascript" src="quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="dev-mode"><a class="header" href="#dev-mode">Dev Mode</a></h1>
<p>Dev mode allows you to write code without assigning weights to functions. Weights are an essential mechanism for measuring and limiting usage, establishing an economic incentive structure, preventing network overload, and mitigating DoS vulnerabilities. Weights are calculated during benchmarking.</p>
<p>If you want to write functions without doing benchmarking, you can use dev mode. You can write the benchmark later on, once you've completed the prototyping and testing.</p>
<p>To convert your pallet to dev mode, use <code>#[frame_support::pallet(dev_mode)]</code></p>
<p>Use:</p>
<pre><code class="language-rust ignore">#[frame_support::pallet(dev_mode)]
pub mod pallet {</code></pre>
<p>instead of</p>
<pre><code class="language-rust ignore">#[frame_support::pallet]
pub mod pallet {</code></pre>
<p>You can write functions without assigning any weight using 	<code>#[pallet::weight(0)]</code></p>
<pre><code class="language-rust ignore">#[pallet::call]
impl&lt;T: Config&gt; Pallet&lt;T&gt; {
	#[pallet::call_index(0)]
	#[pallet::weight(0)]
	pub fn do_something(origin: OriginFor&lt;T&gt;, something: u32) -&gt; DispatchResult {
		let who = ensure_signed(origin)?;

		Something::&lt;T&gt;::put(something);
		Self::deposit_event(Event::SomethingStored { something, who });

		Ok(())
	}</code></pre>
<h2 id="quiz-2"><a class="header" href="#quiz-2">Quiz</a></h2>
<div class="quiz-placeholder" data-quiz-name="dev_mode"  data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;1cd3b6f2-74d1-45a1-b7e2-027cd59b9f6f&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;To write code without assigning weights to functions&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;To assign weights to functions &quot;,&quot;To prevent DoS vulnerabilities&quot;,&quot;To perform benchmarking&quot;],&quot;prompt&quot;:&quot;What is dev mode used for?\n&quot;}},{&quot;id&quot;:&quot;86927f21-1e89-4ee1-9a87-05e48a7e78bf&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;All of the above&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;To prevent network overload&quot;,&quot;To measure and limit usage&quot;,&quot;Mitigating DoS vulnerabilities&quot;],&quot;prompt&quot;:&quot;What is the purpose of weights in a system?\n&quot;}},{&quot;id&quot;:&quot;7081df8e-f1fd-4a78-b570-3b2a4b7b0b87&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;You can write functions without doing benchmarking&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;You can write benchmarks immediately&quot;,&quot;You can assign weights to functions&quot;,&quot;You can prevent network overload&quot;],&quot;prompt&quot;:&quot;What is the benefit of using dev mode?\n&quot;}},{&quot;id&quot;:&quot;e46edf36-d69f-470d-83c7-79675d5df311&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`#[frame_support::pallet(dev_mode)]`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`#[frame_support::pallet]`&quot;,&quot;`#[dev_mode]`&quot;,&quot;`#[frame_support]`&quot;],&quot;prompt&quot;:&quot;What code is used to activate dev mode?\n&quot;}}]}" ></div>
<script type="text/javascript" src="quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="cache-multiple-calls"><a class="header" href="#cache-multiple-calls">Cache Multiple Calls</a></h1>
<p><code>pallets/storage-cache</code>
<a target="_blank" href="https://github.com/reaudito/substrate-recipes/blob/main/polkadot-sdk-solochain-template/pallets/storage-cache/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt ="View on GitHub"/>
</a></p>
<p>Calls to runtime storage have an associated cost and developers should strive to minimize the number
of calls.</p>
<pre><code class="language-rust  ignore">#[pallet::storage]
#[pallet::getter(fn some_copy_value)]
pub(super) type SomeCopyValue&lt;T: Config&gt; = StorageValue&lt;_, u32&gt;;

#[pallet::storage]
#[pallet::getter(fn king_member)]
pub(super) type KingMember&lt;T: Config&gt; = StorageValue&lt;_, T::AccountId&gt;;

#[pallet::storage]
#[pallet::getter(fn group_members)]
pub(super) type GroupMembers&lt;T: Config&gt; = StorageValue&lt;_, Vec&lt;T::AccountId&gt;&gt;;
</code></pre>
<h2 id="copy-types"><a class="header" href="#copy-types">Copy Types</a></h2>
<p>For <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> types, it is easy to reuse
previous storage calls by simply reusing the value, which is automatically cloned upon reuse. In the
code below, the second call is unnecessary:</p>
<pre><code class="language-rust  ignore">pub fn increase_value_no_cache(
    origin: OriginFor&lt;T&gt;,
    some_val: u32,
) -&gt; DispatchResultWithPostInfo {
    let _ = ensure_signed(origin)?;
    let original_call = &lt;SomeCopyValue&lt;T&gt;&gt;::get();
    let some_calculation = original_call
        .unwrap()
        .checked_add(some_val)
        .ok_or("addition overflowed1")?;
    // this next storage call is unnecessary and is wasteful
    let unnecessary_call = &lt;SomeCopyValue&lt;T&gt;&gt;::get();
    // should've just used `original_call` here because u32 is copy
    let another_calculation = some_calculation
        .checked_add(unnecessary_call.unwrap())
        .ok_or("addition overflowed2")?;
    &lt;SomeCopyValue&lt;T&gt;&gt;::put(another_calculation);
    let now = &lt;frame_system::Pallet&lt;T&gt;&gt;::block_number();
    Self::deposit_event(Event::InefficientValueChange(another_calculation, now));
    Ok(().into())
}</code></pre>
<p>Instead, the initial call value should be reused. In this example, the <code>SomeCopyValue</code> value is
<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> so we should prefer the following
code without the unnecessary second call to storage:</p>
<pre><code class="language-rust  ignore">pub fn increase_value_w_copy(
    origin: OriginFor&lt;T&gt;,
    some_val: u32,
) -&gt; DispatchResultWithPostInfo {
    let _ = ensure_signed(origin)?;
    let original_call = &lt;SomeCopyValue&lt;T&gt;&gt;::get();
    let some_calculation = original_call
        .unwrap()
        .checked_add(some_val)
        .ok_or("addition overflowed1")?;
    // uses the original_call because u32 is copy
    let another_calculation = some_calculation
        .checked_add(original_call.unwrap())
        .ok_or("addition overflowed2")?;
    &lt;SomeCopyValue&lt;T&gt;&gt;::put(another_calculation);
    let now = &lt;frame_system::Pallet&lt;T&gt;&gt;::block_number();
    Self::deposit_event(Event::BetterValueChange(another_calculation, now));
    Ok(().into())
}</code></pre>
<h2 id="clone-types"><a class="header" href="#clone-types">Clone Types</a></h2>
<p>If the type was not <code>Copy</code>, but was <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>,
then it is still better to clone the value in the method than to make another call to runtime
storage.</p>
<p>The runtime methods enable the calling account to swap the <code>T::AccountId</code> value in storage if</p>
<ol>
<li>the existing storage value is not in <code>GroupMembers</code> AND</li>
<li>the calling account is in <code>GroupMembers</code></li>
</ol>
<p>The first implementation makes a second unnecessary call to runtime storage instead of cloning the
call for <code>existing_key</code>:</p>
<pre><code class="language-rust  ignore">pub fn swap_king_no_cache(origin: OriginFor&lt;T&gt;) -&gt; DispatchResultWithPostInfo {
    let new_king = ensure_signed(origin)?;
    let existing_king = &lt;KingMember&lt;T&gt;&gt;::get();

    // only places a new account if
    // (1) the existing account is not a member &amp;&amp;
    // (2) the new account is a member
    ensure!(
        !Self::is_member(&amp;existing_king.unwrap()),
        "current king is a member so maintains priority"
    );
    ensure!(
        Self::is_member(&amp;new_king),
        "new king is not a member so doesn't get priority"
    );

    // BAD (unnecessary) storage call
    let old_king = &lt;KingMember&lt;T&gt;&gt;::get();
    // place new king
    &lt;KingMember&lt;T&gt;&gt;::put(new_king.clone());

    Self::deposit_event(Event::InefficientKingSwap(old_king.unwrap(), new_king));
    Ok(().into())
}</code></pre>
<p>If the <code>existing_key</code> is used without a <code>clone</code> in the event emission instead of <code>old_king</code>, then
the compiler returns the following error:</p>
<pre><code class="language-bash">error[E0382]: use of moved value: `new_king`
   --&gt; pallets/storage-cache/src/lib.rs:190:79
    |
168 |             let new_king = ensure_signed(origin)?;
    |                 -------- move occurs because `new_king` has type `&lt;T as frame_system::Config&gt;::AccountId`, which does not implement the `Copy` trait
...
188 |             &lt;KingMember&lt;T&gt;&gt;::put(new_king);
    |                                  -------- value moved here
189 |
190 |             Self::deposit_event(Event::InefficientKingSwap(old_king.unwrap(), new_king));
    |                                                                               ^^^^^^^^ value used here after move
    |
help: consider cloning the value if the performance cost is acceptable
    |
188 |             &lt;KingMember&lt;T&gt;&gt;::put(new_king.clone());
    |                                          ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `pallet-storage-cache` (lib) due to 1 previous error
</code></pre>
<p>Fixing this only requires cloning the original value before it is moved:</p>
<pre><code class="language-rust  ignore">pub fn swap_king_with_cache(origin: OriginFor&lt;T&gt;) -&gt; DispatchResultWithPostInfo {
    let new_king = ensure_signed(origin)?;
    let existing_king = &lt;KingMember&lt;T&gt;&gt;::get();
    // prefer to clone previous call rather than repeat call unnecessarily
    let old_king = existing_king.clone();

    // only places a new account if
    // (1) the existing account is not a member &amp;&amp;
    // (2) the new account is a member
    ensure!(
        !Self::is_member(&amp;existing_king.unwrap()),
        "current king is a member so maintains priority"
    );
    ensure!(
        Self::is_member(&amp;new_king),
        "new king is not a member so doesn't get priority"
    );

    // &lt;no (unnecessary) storage call here&gt;
    // place new king
    &lt;KingMember&lt;T&gt;&gt;::put(new_king.clone());

    Self::deposit_event(Event::BetterKingSwap(old_king.unwrap(), new_king));
    Ok(().into())
}</code></pre>
<p>Not all types implement <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> or
<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, so it is important to discern other
patterns that minimize and alleviate the cost of calls to storage.</p>
<h2 id="quiz-3"><a class="header" href="#quiz-3">Quiz</a></h2>
<div class="quiz-placeholder" data-quiz-name="cache"  data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;1f6a3896-47e3-4857-8647-a65098e9b66d&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Because runtime storage calls have an associated cost.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Because runtime storage calls are free.&quot;,&quot;To avoid errors in the code.&quot;,&quot;To reduce the number of variables.&quot;],&quot;prompt&quot;:&quot;Why should developers minimize calls to runtime storage?\n&quot;}},{&quot;context&quot;:&quot;\n&quot;,&quot;id&quot;:&quot;6a44ff98-c682-47f0-9f86-51401362dc04&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Clone the value in the method.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Avoid using the type altogether.&quot;,&quot;Make another call to runtime storage.&quot;,&quot;Convert the type to Copy.&quot;],&quot;prompt&quot;:&quot;If a type is not Copy but is Clone, what is the recommended practice to avoid extra runtime storage calls?\n&quot;}}]}" ></div>
<script type="text/javascript" src="quiz/quiz-embed.iife.js"></script><link rel="stylesheet" type="text/css" href="quiz/style.css"><div style="break-before: page; page-break-before: always;"></div><h1 id="using-vectors-as-sets"><a class="header" href="#using-vectors-as-sets">Using Vectors as Sets</a></h1>
<p><code>pallets/vec-set</code>
<a target="_blank" href="">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt ="View on GitHub"/>
</a></p>
<p>A <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">Set</a> is an unordered data structure
that stores entries without duplicates. Substrate's storage API does not provide a way to declare
sets explicitly, but they can be implemented using either vectors or maps.</p>
<p>This recipe demonstrates how to implement a storage set on top of a vector, and explores the
performance of the implementation. When implementing a set in your own runtime, you should compare
this technique to implementing a <a href="./map_set.html"><code>map-set</code></a>.</p>
<p>In this pallet we implement a set of <code>AccountId</code>s. We do not use the set for anything in this
pallet; we simply maintain the set. Using the set is demonstrated in the recipe on
<a href="./pallet-coupling.html">pallet coupling</a>. We provide dispatchable calls to add and remove members,
ensuring that the number of members never exceeds a hard-coded maximum.</p>
<pre><code class="language-rust  ignore">/// A maximum number of members. When membership reaches this number, no new members may join.
pub const MAX_MEMBERS: usize = 16;</code></pre>
<h2 id="storage-item"><a class="header" href="#storage-item">Storage Item</a></h2>
<p>We will store the members of our set in a Rust
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>. A <code>Vec</code> is a collection of elements that
is ordered and may contain duplicates. Because the <code>Vec</code> provides more functionality than our set
needs, we are able to build a set from the <code>Vec</code>. We declare our single storage item as so</p>
<pre><code class="language-rust  ignore">#[pallet::storage]
#[pallet::getter(fn members)]
pub(super) type Members&lt;T: Config&gt; = StorageValue&lt;_, Vec&lt;T::AccountId&gt;, ValueQuery&gt;;</code></pre>
<p>In order to use the <code>Vec</code> successfully as a set, we will need to manually ensure that no duplicate
entries are added. To ensure reasonable performance, we will enforce that the <code>Vec</code> always remains
sorted. This allows for quickly determining whether an item is present using a
<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a>.</p>
<h2 id="adding-members"><a class="header" href="#adding-members">Adding Members</a></h2>
<p>Any user may join the membership set by calling the <code>add_member</code> dispatchable, providing they are
not already a member and the membership limit has not been reached. We check for these two
conditions first, and then insert the new member only after we are sure it is safe to do so. This is
an example of the mnemonic idiom, "<strong>verify first write last</strong>".</p>
<pre><code class="language-rust  ignore">pub fn add_member(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {
	let new_member = ensure_signed(origin)?;

	let mut members = Members::&lt;T&gt;::get();
	ensure!(members.len() &lt; MAX_MEMBERS, Error::&lt;T&gt;::MembershipLimitReached);

	// We don't want to add duplicate members, so we check whether the potential new
	// member is already present in the list. Because the list is always ordered, we can
	// leverage the binary search which makes this check O(log n).
	match members.binary_search(&amp;new_member) {
		// If the search succeeds, the caller is already a member, so just return
		Ok(_) =&gt; Err(Error::&lt;T&gt;::AlreadyMember.into()),
		// If the search fails, the caller is not a member and we learned the index where
		// they should be inserted
		Err(index) =&gt; {
			members.insert(index, new_member.clone());
			Members::&lt;T&gt;::put(members);
			Self::deposit_event(Event::MemberAdded(new_member));
			Ok(())
		}
	}
}</code></pre>
<p>If it turns out that the caller is not already a member, the binary search will fail. In this case
it still returns the index into the <code>Vec</code> at which the member would have been stored had they been
present. We then use this information to insert the member at the appropriate location, thus
maintaining a sorted <code>Vec</code>.</p>
<h2 id="removing-a-member"><a class="header" href="#removing-a-member">Removing a Member</a></h2>
<p>Removing a member is straightforward. We begin by looking for the caller in the list. If not
present, there is no work to be done. If the caller is present, the search algorithm returns her
index, and she can be removed.</p>
<pre><code class="language-rust  ignore">fn remove_member(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {
	let old_member = ensure_signed(origin)?;

	let mut members = Members::&lt;T&gt;::get();

	// We have to find out where, in the sorted vec the member is, if anywhere.
	match members.binary_search(&amp;old_member) {
		// If the search succeeds, the caller is a member, so remove her
		Ok(index) =&gt; {
			members.remove(index);
			Members::&lt;T&gt;::put(members);
			Self::deposit_event(Event::MemberRemoved(old_member));
			Ok(())
		},
		// If the search fails, the caller is not a member, so just return
		Err(_) =&gt; Err(Error::&lt;T&gt;::NotMember.into()),
	}
}</code></pre>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Now that we have built our set, let's analyze its performance in some common operations.</p>
<h3 id="membership-check"><a class="header" href="#membership-check">Membership Check</a></h3>
<p>In order to check for the presence of an item in a <code>vec-set</code>, we make a single storage read, decode
the entire vector, and perform a binary search.</p>
<p>DB Reads: O(1) Decoding: O(n) Search: O(log n)</p>
<h3 id="updating"><a class="header" href="#updating">Updating</a></h3>
<p>Updates to the set, such as adding and removing members as we demonstrated, requires first
performing a membership check. It also requires re-encoding the entire <code>Vec</code> and storing it back in
the database. Finally, it still costs the normal
<a href="https://stackoverflow.com/q/200384/4184410">amortized constant time</a> associated with mutating a
<code>Vec</code>.</p>
<p>DB Writes: O(1) Encoding: O(n)</p>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<p>Iterating over all items in a <code>vec-set</code> is achieved by using the <code>Vec</code>'s own
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>iter</code> method</a>. The entire set can
be read from storage in one go, and each item must be decoded. Finally, the actual processing you do
on the items will take some time.</p>
<p>DB Reads: O(1) Decoding: O(n) Processing: O(n)</p>
<p>Because accessing the database is a relatively slow operation, reading the entire list in a single
read is a big win. If you need to iterate over the data frequently, you may want a <code>vec-set</code>.</p>
<h3 id="a-note-on-weights"><a class="header" href="#a-note-on-weights">A Note on Weights</a></h3>
<p>It is always important that the weight associated with your dispatchables represent the actual time
it takes to execute them. In this pallet, we have provided an upper bound on the size of the set,
which places an upper bound on the computation - this means we can use constant weight annotations.
Your set operations should either have a maximum size or a <a href="./weights.html">custom weight function</a>
that captures the computation appropriately.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-maps-as-sets"><a class="header" href="#using-maps-as-sets">Using Maps as Sets</a></h1>
<p><code>pallets/map-set</code>
<a target="_blank" href="">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt ="View on GitHub"/>
</a></p>
<p>A <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">Set</a> is an unordered data structure
that stores entries without duplicates. Substrate's storage API does not provide a way to declare
sets explicitly, but they can be implemented using either vectors or maps.</p>
<p>This recipe shows how to implement a storage set on top of a map, and explores the performance of
the implementation. When implementing a set in your own runtime, you should compare this technique
to implementing a <a href="./vec_set.html"><code>vec-set</code></a>.</p>
<p>In this pallet we implement a set of <code>AccountId</code>s. We do not use the set for anything in this
pallet; we simply maintain its membership. Using the set is demonstrated in the recipe on
<a href="./pallet-coupling.html">pallet coupling</a>. We provide dispatchable calls to add and remove members,
ensuring that the number of members never exceeds a hard-coded maximum.</p>
<pre><code class="language-rust  ignore">/// A maximum number of members. When membership reaches this number, no new members may join.
pub const MAX_MEMBERS: u32 = 16;</code></pre>
<h2 id="storage-item-1"><a class="header" href="#storage-item-1">Storage Item</a></h2>
<p>We will store the members of our set as the keys in one of Substrate's
<a href="https://substrate.dev/rustdocs/latest/frame_support/storage/trait.StorageMap.html"><code>StorageMap</code></a>s. There is also
a recipe specifically about <a href="./storage-maps.html">using storage maps</a>. The storage map itself does not
track its size internally, so we introduce a second storage value for this purpose.</p>
<pre><code class="language-rust  ignore">#[pallet::storage]
#[pallet::getter(fn members)]
pub(super) type Members&lt;T: Config&gt; =
	StorageMap&lt;_, Blake2_128Concat, T::AccountId, (), ValueQuery&gt;;

#[pallet::storage]
pub(super) type MemberCount&lt;T&gt; = StorageValue&lt;_, u32, ValueQuery&gt;;
</code></pre>
<p>The <em>value</em> stored in the map is <code>()</code> because we only care about the keys.</p>
<h2 id="adding-members-1"><a class="header" href="#adding-members-1">Adding Members</a></h2>
<p>Any user may join the membership set by calling the <code>add_member</code> dispatchable, so long as they are
not already a member and the membership limit has not been reached. We check for these two
conditions first, and then insert the new member only after we are sure it is safe to do so.</p>
<pre><code class="language-rust  ignore">fn add_member(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {
	let new_member = ensure_signed(origin)?;

	let member_count = MemberCount::get();
	ensure!(member_count &lt; MAX_MEMBERS, Error::&lt;T&gt;::MembershipLimitReached);

	// We don't want to add duplicate members, so we check whether the potential new
	// member is already present in the list. Because the membership is stored as a hash
	// map this check is constant time O(1)
	ensure!(!Members::&lt;T&gt;::contains_key(&amp;new_member), Error::&lt;T&gt;::AlreadyMember);

	// Insert the new member and emit the event
	Members::&lt;T&gt;::insert(&amp;new_member, ());
	MemberCount::put(member_count + 1); // overflow check not necessary because of maximum
	Self::deposit_event(RawEvent::MemberAdded(new_member));
	Ok(())
}</code></pre>
<p>When we successfully add a new member, we also manually update the size of the set.</p>
<h2 id="removing-a-member-1"><a class="header" href="#removing-a-member-1">Removing a Member</a></h2>
<p>Removing a member is straightforward. We begin by looking for the caller in the list. If not
present, there is no work to be done. If the caller is present, we simply remove them and update the
size of the set.</p>
<pre><code class="language-rust  ignore">fn remove_member(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {
	let old_member = ensure_signed(origin)?;

	ensure!(Members::&lt;T&gt;::contains_key(&amp;old_member), Error::&lt;T&gt;::NotMember);

	Members::&lt;T&gt;::remove(&amp;old_member);
	MemberCount::mutate(|v| *v -= 1);
	Self::deposit_event(RawEvent::MemberRemoved(old_member));
	Ok(())
}</code></pre>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<p>Now that we have built our set, let's analyze its performance in some common operations.</p>
<h3 id="membership-check-1"><a class="header" href="#membership-check-1">Membership Check</a></h3>
<p>In order to check for the presence of an item in a map set, we make a single storage read. If we
only care about the presence or absence of the item, we don't even need to decode it. This constant
time membership check is the greatest strength of a map set.</p>
<p>DB Reads: O(1)</p>
<h3 id="updating-1"><a class="header" href="#updating-1">Updating</a></h3>
<p>Updates to the set, such as adding and removing members as we demonstrated, requires first
performing a membership check. Additions also require encooding the new item.</p>
<p>DB Reads: O(1) Encoding: O(1) DB Writes: O(1)</p>
<p>If your set operations will require a lot of membership checks or mutation of individual items, you
may want a <code>map-set</code>.</p>
<h3 id="iteration-1"><a class="header" href="#iteration-1">Iteration</a></h3>
<p>Iterating over all items in a <code>map-set</code> is achieved by using the
<a href="https://substrate.dev/rustdocs/latest/frame_support/storage/trait.IterableStorageMap.html"><code>IterableStorageMap</code> trait</a>,
which iterates <code>(key, value)</code> pairs (although in this case, we don't care about the values). Because
each map entry is stored as an individual trie node, iterating a map set requires a database read
for each item. Finally, the actual processing of the items will take some time.</p>
<p>DB Reads: O(n) Decoding: O(n) Processing: O(n)</p>
<p>Because accessing the database is a relatively slow operation, returning to the database for each
item is quite expensive. If your set operations will require frequent iterating, you will probably
prefer a <a href="./vec-set.html"><code>vec-set</code></a>.</p>
<h3 id="a-note-on-weights-1"><a class="header" href="#a-note-on-weights-1">A Note on Weights</a></h3>
<p>It is always important that the weight associated with your dispatchables represent the actual time
it takes to execute them. In this pallet, we have provided an upper bound on the size of the set,
which places an upper bound on the computation - this means we can use constant weight annotations.
Your set operations should either have a maximum size or a <a href="./weights.html">custom weight function</a>
that captures the computation appropriately.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
